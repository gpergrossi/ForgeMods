package dev.mortus.chunks;

import java.awt.Point;
import java.awt.geom.Rectangle2D;
import java.util.Iterator;

public class View2DChunkManager<T extends Chunk> extends ChunkManager<T> {
	
	Rectangle2D view;
	
	public View2DChunkManager(ChunkLoader<T> loader) {
		super(loader, 4, 40);
	}
	
	public View2DChunkManager(ChunkLoader<T> loader, int numWorkers) {
		super(loader, numWorkers, 40);
	}
	
	public View2DChunkManager(ChunkLoader<T> loader, int numWorkers, int initialQueueSize) {
		super(loader, numWorkers, initialQueueSize);
	}
	
	public void setView(Rectangle2D view) {
		this.view = view;
		
		Point upperLeft = getChunkCoordinate(view.getMinX(), view.getMinY());
		Point lowerRight = getChunkCoordinate(view.getMaxX(), view.getMaxY());
		int minX = upperLeft.x, minY = upperLeft.y;
		int maxX = lowerRight.x, maxY = lowerRight.y;
		
		// For priority evaluation
		int centerX = (minX + maxX) / 2;
		int centerY = (minY + maxY) / 2;
		center = new Point(centerX, centerY);
	}
	
	public void touchAll() {
		Point upperLeft = getChunkCoordinate(view.getMinX(), view.getMinY());
		Point lowerRight = getChunkCoordinate(view.getMaxX(), view.getMaxY());
		int minX = upperLeft.x, minY = upperLeft.y;
		int maxX = lowerRight.x, maxY = lowerRight.y;
		
		// For priority evaluation
		int centerX = (minX + maxX) / 2;
		int centerY = (minY + maxY) / 2;
		center = new Point(centerX, centerY);
		
		// For unloading
		currentViewIteration++;
		
		// Load new chunks / update lastSeen
		for (int x = minX; x <= maxX; x++) {
			for (int y = minY; y <= maxY; y++) {
				T chunk = loader.getChunk(x, y);
				chunk.lastSeen = currentViewIteration;
				if (!chunk.isLoaded()) queueLoad(chunk);
			}
		}
		
		// Unload old chunks
		acquire("loadedChunks", loadedChunksLock);
		long maxAge = loader.getMaxChunkAge();
		T chunk = loadedChunks.peek();
		while (chunk != null && (currentViewIteration - chunk.lastSeen) > maxAge) {
			queueUnload(chunk);
			loadedChunks.remove(chunk);
			chunk = loadedChunks.peek();
		}
		release("loadedChunks", loadedChunksLock);
		
		// Stop loading off-screen chunks
		acquire("loadingQueue", loadingQueueLock);
		Iterator<T> iterator = loadingQueue.iterator();
		while (iterator.hasNext()) {
			chunk = iterator.next();
			if ((currentViewIteration - chunk.lastSeen) > 0) {
				chunk.loading = false;
				iterator.remove();
			}
		}
		release("loadingQueue", loadingQueueLock);
	}
	
}
