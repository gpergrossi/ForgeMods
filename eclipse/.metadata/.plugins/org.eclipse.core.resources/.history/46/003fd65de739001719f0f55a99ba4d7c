package dev.mortus.cells;

import java.awt.Point;
import java.awt.geom.Point2D;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Random;

import dev.mortus.util.math.func2d.Function2D;

public class InfiniteVoronoi {

	private static Random random = new Random();
	private static final long MAX_INTEGER = (long) Integer.MAX_VALUE;
	
	int now;
	long globalSeed;
	double gridSize;
	
	int chunkCacheCapacity;
	Map<Point, SiteInfo> chunkCache;
	
	public InfiniteVoronoi(double gridSize, long seed, int chunkCacheCapacity) {
		this.gridSize = gridSize;
		this.globalSeed = seed;
		this.now = Integer.MIN_VALUE;
		
		if (chunkCacheCapacity < 9) chunkCacheCapacity = 9;
		this.chunkCache = new LRUHashMap<>(chunkCacheCapacity);
		this.chunkCacheCapacity = chunkCacheCapacity;
	}
	
	public SiteInfo getSite(double x, double y) {
		int chunkX = (int) Math.floor(x / gridSize);
		int chunkY = (int) Math.floor(y / gridSize);
		Point chunkKey = new Point(chunkX, chunkY);
		
		SiteInfo site = getSite(chunkKey, true);
		return site.getClosestSite(x, y);
	}
	
	private SiteInfo getSite(Point chunkKey, boolean init) {
		SiteInfo info = chunkCache.get(chunkKey);
		if (info == null) {
			if (chunkCache.size() >= chunkCacheCapacity) evictOne();
			info = new SiteInfo(this, chunkKey);
			chunkCache.put(chunkKey, info);
		}
		if (init) info.init();
		info.lastUsed = ++now;
		
		return info;
	}

	private void evictOne() {
		Map.Entry<Point, SiteInfo> oldest = null;
		for (Map.Entry<Point, SiteInfo> entry : chunkCache.entrySet()) {
			SiteInfo info = entry.getValue();
			if (oldest == null || oldest.getValue().lastUsed > info.lastUsed) oldest = entry;
		}
		if (oldest == null) return;
		boolean success = chunkCache.remove(oldest.getKey(), oldest.getValue());
		if (!success) System.err.println("!!!! weird error: dev.mortus.cells.GridInfinitVoronoi2D.evictOne() !!!!");
	}

	private static class SiteInfo {
		int lastUsed;
		
		InfiniteVoronoi container;
		int chunkX, chunkY;
		
		boolean initialized = false;
		
		long seed;
		Point2D site;
		
		SiteInfo[] neighbors;
		
		public SiteInfo(InfiniteVoronoi container, Point chunkKey) {
			this.container = container;
			this.chunkX = chunkKey.x;
			this.chunkY = chunkKey.y;
			
			this.seed = createSeed(chunkX, chunkY);
			random.setSeed(seed);
			double ptX = (chunkX+random.nextDouble())*container.gridSize;
			double ptY = (chunkY+random.nextDouble())*container.gridSize;
			this.site = new Point2D.Double(ptX, ptY);
		}
		
		public void init() {
			if (this.initialized) return;
			this.neighbors = new SiteInfo[9];
			
			int i = 0;
			for (int iy = -1; iy <= 1; iy++) {
				for (int ix = -1; ix <= 1; ix++) {
					if (i == 4) { i++; continue; }
					neighbors[i] = container.getSite(new Point(chunkX+ix, chunkY+iy), false);
					i++;
				}	
			}
			neighbors[4] = this;
			
			this.initialized = true;
		}
		
		public SiteInfo getClosestSite(double x, double y) {			
			double lowestDistance = Double.MAX_VALUE;
			SiteInfo winner = null;
			for (int i = 0; i < 9; i++) {
				double dist = neighbors[i].site.distance(x, y);
				if (dist < lowestDistance) {
					lowestDistance = dist;
					winner = neighbors[i];
				}
			}
			return winner;
		}
		
		private long createSeed(int chunkX, int chunkY) {
			Random rand = new Random(container.globalSeed);
			long rx = (chunkX * (long) rand.nextInt(Integer.MAX_VALUE)) % MAX_INTEGER;
			long ry = (chunkY * (long) rand.nextInt(Integer.MAX_VALUE)) % MAX_INTEGER;
			rand.setSeed(rx ^ (ry << 32) ^ rand.nextLong());
			return rand.nextLong();	
		}
		
	}
	
}
