package dev.mortus.cells;

import java.awt.Point;
import java.awt.geom.Point2D;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

import dev.mortus.util.math.func2d.Function2D;

public class GridInfiniteVoronoi2D implements Function2D {

	private static final long MAX_INTEGER = (long) Integer.MAX_VALUE;
	
	int now;
	long globalSeed;
	double gridSize;
	
	int chunkCacheCapacity;
	Map<Point, ChunkInfo> chunkCache;
	
	public GridInfiniteVoronoi2D(double gridSize, long seed, int chunkCacheCapacity) {
		this.gridSize = gridSize;
		this.globalSeed = seed;
		this.now = Integer.MIN_VALUE;
		
		if (chunkCacheCapacity < 9) chunkCacheCapacity = 9;
		this.chunkCache = new HashMap<>(chunkCacheCapacity);
		this.chunkCacheCapacity = chunkCacheCapacity;
	}
	
	
	@Override
	public double getValue(double x, double y) {
		int chunkX = (int) Math.floor(x / gridSize);
		int chunkY = (int) Math.floor(y / gridSize);
		Point chunkKey = new Point(chunkX, chunkY);
		
		ChunkInfo chunk = getChunkInfo(chunkKey);

		Random r = new Random();
		double closestDist2 = Double.MAX_VALUE;
		int closestIndex = -1;
		
		int i = 0;
		for (int iy = -1; iy <= 1; iy++) {
			for (int ix = -1; ix <= 1; ix++) {
				r.setSeed(chunk.seeds[i]);
				double ptX = (chunkX+ix+r.nextDouble())*gridSize;
				double ptY = (chunkY+iy+r.nextDouble())*gridSize;
				double ptDist2 = distance2(x, y, ptX, ptY);
				if (ptDist2 < closestDist2) {
					closestDist2 = ptDist2;
					closestIndex = i;
				}
				i++;
			}	
		}
		
		//return 1.0-(1.0/((Math.sqrt(closestDist2)/fadeRadius)+1.0));
		r.setSeed(chunk.seeds[closestIndex]);
		return r.nextDouble();
	}
	
	private ChunkInfo getChunkInfo(Point chunkKey) {
		ChunkInfo info = chunkCache.get(chunkKey);
		if (info == null) {
			if (chunkCache.size() >= chunkCacheCapacity) evictOne();
			info = new ChunkInfo(this, chunkKey);
			chunkCache.put(chunkKey, info);
			info.init();
		}
		info.lastUsed = ++now;
		
		return info;
	}

	private void evictOne() {
		Map.Entry<Point, ChunkInfo> oldest = null;
		for (Map.Entry<Point, ChunkInfo> entry : chunkCache.entrySet()) {
			ChunkInfo info = entry.getValue();
			if (oldest == null || oldest.getValue().lastUsed > info.lastUsed) oldest = entry;
		}
		if (oldest == null) return;
		boolean success = chunkCache.remove(oldest.getKey(), oldest.getValue());
		if (!success) System.err.println("!!!! weird error: dev.mortus.cells.GridInfinitVoronoi2D.evictOne() !!!!");
	}

	private double distance2(double x1, double y1, double x2, double y2) {
		double dx = x2-x1;
		double dy = y2-y1;
		return dx*dx + dy*dy;
	}

	private static class ChunkInfo {
		
		private static Random random = new Random();
		
		int lastUsed;
		
		GridInfiniteVoronoi2D container;
		int chunkX, chunkY;
		
		boolean initialized = false;
		
		long seed;
		Point2D site;
		
		ChunkInfo[] neighbors;
		
		public ChunkInfo(GridInfiniteVoronoi2D container, Point chunkKey) {
			this.container = container;
			this.chunkX = chunkKey.x;
			this.chunkY = chunkKey.y;
			
			this.seed = createSeed(chunkX, chunkY);
			random.setSeed(seed);
			double ptX = (chunkX+random.nextDouble())*container.gridSize;
			double ptY = (chunkY+random.nextDouble())*container.gridSize;
			this.site = new Point2D.Double(ptX, ptY);
		}
		
		public void init() {
			if (this.initialized) return;
						
			int i = 0;
			for (int iy = -1; iy <= 1; iy++) {
				for (int ix = -1; ix <= 1; ix++) {
					if (i == 4) continue;
					neighbors[]
					i++;
				}	
			}
			neighbors[4] = this;
			
			this.initialized = true;
		}
		
		public ChunkInfo getClosestSite(double x, double y) {
			double lowestDistance = Double.MAX_VALUE;
			Point2D winner = null;
			for (int i = 0; i < 9; i++) {
				double dist = sites[i].distance(x, y);
				if (dist < lowestDistance) {
					lowestDistance = dist;
					winner = sites[i];
				}
			}
			return winner;
		}
		
		private long createSeed(int chunkX, int chunkY) {
			Random rand = new Random(container.globalSeed);
			long rx = (chunkX * (long) rand.nextInt(Integer.MAX_VALUE)) % MAX_INTEGER;
			long ry = (chunkY * (long) rand.nextInt(Integer.MAX_VALUE)) % MAX_INTEGER;
			rand.setSeed(rx ^ (ry << 32) ^ rand.nextLong());
			return rand.nextLong();	
		}
		
	}
	
}
