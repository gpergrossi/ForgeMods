package dev.mortus.cells;

import java.awt.Point;
import java.awt.geom.Point2D;
import java.util.Map;
import java.util.Random;

public class InfiniteVoronoi {

	private static Random random = new Random();
	private static final long MAX_INTEGER = (long) Integer.MAX_VALUE;
	
	int now;
	long globalSeed;
	double gridSize;
	
	int chunkCacheCapacity;
	Map<Point, Cell> chunkCache;
	
	public InfiniteVoronoi(double gridSize, long seed, int chunkCacheCapacity) {
		this.gridSize = gridSize;
		this.globalSeed = seed;
		this.now = Integer.MIN_VALUE;
		
		if (chunkCacheCapacity < 9) chunkCacheCapacity = 9; // should at least be 9 or it saves NO effort
		this.chunkCache = new LRUHashMap<>(chunkCacheCapacity);
		this.chunkCacheCapacity = chunkCacheCapacity;
	}
	
	public Cell getCell(double x, double y) {
		int chunkX = (int) Math.floor(x / gridSize);
		int chunkY = (int) Math.floor(y / gridSize);
		Point chunkKey = new Point(chunkX, chunkY);
		
		Cell site = getCell(chunkKey, true);
		return site.getClosestSite(x, y);
	}
	
	private Cell getCell(Point chunkKey, boolean init) {
		Cell info = chunkCache.get(chunkKey);
		if (info == null) {
			info = new Cell(this, chunkKey);
			chunkCache.put(chunkKey, info);
		}
		if (init) info.init();
		info.lastUsed = ++now;
		
		return info;
	}

	private static class Cell {
		int lastUsed;
		
		InfiniteVoronoi container;
		int chunkX, chunkY;
		
		boolean initialized = false;
		
		long seed;
		Point2D site;
		
		Cell[] neighbors;
		
		public Cell(InfiniteVoronoi container, Point chunkKey) {
			this.container = container;
			this.chunkX = chunkKey.x;
			this.chunkY = chunkKey.y;
			
			this.seed = createSeed(chunkX, chunkY);
			random.setSeed(seed);
			double ptX = (chunkX+random.nextDouble())*container.gridSize;
			double ptY = (chunkY+random.nextDouble())*container.gridSize;
			this.site = new Point2D.Double(ptX, ptY);
		}
		
		public void init() {
			if (this.initialized) return;
			this.neighbors = new Cell[9];
			
			int i = 0;
			for (int iy = -1; iy <= 1; iy++) {
				for (int ix = -1; ix <= 1; ix++) {
					if (i == 4) { i++; continue; }
					neighbors[i] = container.getCell(new Point(chunkX+ix, chunkY+iy), false);
					i++;
				}	
			}
			neighbors[4] = this;
			
			this.initialized = true;
		}
		
		public Cell getClosestSite(double x, double y) {			
			double lowestDistance = Double.MAX_VALUE;
			Cell winner = null;
			for (int i = 0; i < 9; i++) {
				double dist = neighbors[i].site.distance(x, y);
				if (dist < lowestDistance) {
					lowestDistance = dist;
					winner = neighbors[i];
				}
			}
			return winner;
		}
		
		private long createSeed(int chunkX, int chunkY) {
			Random rand = new Random(container.globalSeed);
			long rx = (chunkX * (long) rand.nextInt(Integer.MAX_VALUE)) % MAX_INTEGER;
			long ry = (chunkY * (long) rand.nextInt(Integer.MAX_VALUE)) % MAX_INTEGER;
			rand.setSeed(rx ^ (ry << 32) ^ rand.nextLong());
			return rand.nextLong();	
		}
		
	}
	
}
